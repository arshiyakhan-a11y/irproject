import 'dart:convert';
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart';
import 'api_service.dart';
import 'package:path_provider/path_provider.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:flutter/services.dart';

void main() {
  runApp(const VtonApp());
}

class VtonApp extends StatelessWidget {
  const VtonApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'VTON Flutter â€” Option A',
      theme: ThemeData(useMaterial3: true),
      home: const HomeScreen(),
    );
  }
}

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});
  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  // API Service: Connects Flutter front-end to backend model
  final api = ApiService(baseUrl: 'http://10.0.2.2:5000'); // Android emulator -> host machine

  PlatformFile? person;
  PlatformFile? garment;
  String? resultDataUrl;
  bool loading = false;
  String statusText = '';

  // --------------------------
  // Data Mining Concept:
  // --------------------------
  // These images (person and garment) can act as "data points".
  // Later, we can use clustering on garment images to find similar styles/colors
  // or use association rules to recommend garments that go well together.

  Future<void> pickPerson() async {
    final res = await FilePicker.platform.pickFiles(
      withReadStream: false,
      type: FileType.image,
      allowMultiple: false,
    );
    if (res == null) return;
    setState(() => person = res.files.first);
  }

  Future<void> pickGarment() async {
    final res = await FilePicker.platform.pickFiles(
      withReadStream: false,
      type: FileType.image,
      allowMultiple: false,
    );
    if (res == null) return;
    setState(() => garment = res.files.first);
  }

  Future<File> _platformFileToFile(PlatformFile pf) async {
    if (kIsWeb) {
      final bytes = pf.bytes;
      if (bytes == null) throw Exception('No bytes in web file');
      final dir = await getTemporaryDirectory();
      final f = File('${dir.path}/${pf.name}');
      await f.writeAsBytes(bytes);
      return f;
    } else {
      if (pf.path != null) {
        return File(pf.path!);
      } else {
        final bytes = pf.bytes;
        if (bytes == null) throw Exception('Unable to access file bytes');
        final dir = await getTemporaryDirectory();
        final f = File('${dir.path}/${pf.name}');
        await f.writeAsBytes(bytes);
        return f;
      }
    }
  }

  // --------------------------
  // Submit images to backend
  // --------------------------
  // Backend can be enhanced with:
  // 1. Classification: Detect garment type (shirt, dress, pants)
  // 2. Clustering: Group garments by color, pattern, or style
  // 3. Recommendation: Suggest similar garments from dataset
  Future<void> submitTryOn() async {
    if (person == null || garment == null) {
      setState(() => statusText = 'Select both person and garment images first.');
      return;
    }

    setState(() {
      loading = true;
      resultDataUrl = null;
      statusText = 'Uploading images...';
    });

    try {
      final personFile = await _platformFileToFile(person!);
      final garmentFile = await _platformFileToFile(garment!);

      setState(() => statusText = 'Calling backend / model...');

      final resp = await api.tryOn(personFile: personFile, garmentFile: garmentFile);

      // --------------------------
      // Data Mining Concept:
      // --------------------------
      // resp could be stored in a database to analyze:
      // - Most popular garment types/colors (frequency analysis)
      // - User preferences for future recommendations (user profiling)
      setState(() {
        resultDataUrl = resp;
        statusText = 'Try-on successful';
      });
    } catch (e) {
      setState(() {
        statusText = 'Error: ${e.toString()}';
      });
    } finally {
      setState(() => loading = false);
    }
  }

  Future<void> downloadResult() async {
    if (resultDataUrl == null) return;
    if (kIsWeb) {
      await launchUrl(Uri.parse(resultDataUrl!));
    } else {
      final bytes = _dataUrlToBytes(resultDataUrl!);
      final dir = await getTemporaryDirectory();
      final file = File('${dir.path}/vton_result_${DateTime.now().millisecondsSinceEpoch}.png');
      await file.writeAsBytes(bytes);
      setState(() {
        statusText = 'Saved to ${file.path}';
      });
    }
  }

  List<int> _dataUrlToBytes(String dataUrl) {
    final split = dataUrl.split(',');
    final header = split[0];
    final data = split[1];
    if (header.contains('base64')) {
      return base64Decode(data);
    } else {
      return utf8.encode(Uri.decodeComponent(data));
    }
  }

  void copyResultToClipboard() {
    if (resultDataUrl == null) return;
    Clipboard.setData(ClipboardData(text: resultDataUrl));
    setState(() => statusText = 'Result data URL copied to clipboard');
  }

  @override
  Widget build(BuildContext context) {
    Widget imagePreview(PlatformFile? file, {double h = 160}) {
      if (file == null) return Container(
        height: h,
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(10),
          color: Colors.grey[100],
        ),
        alignment: Alignment.center,
        child: const Text('No image selected'),
      );
      if (kIsWeb && file.bytes != null) {
        return Image.memory(file.bytes!, height: h, fit: BoxFit.contain);
      } else if (file.path != null) {
        return Image.file(File(file.path!), height: h, fit: BoxFit.contain);
      } else if (file.bytes != null) {
        return Image.memory(file.bytes!, height: h, fit: BoxFit.contain);
      } else {
        return Container(height: h, child: const Center(child: Text('Cannot preview')));
      }
    }

    return Scaffold(
      appBar: AppBar(
          title: const Text('Virtual Try-On (Option A)'),
          backgroundColor: Colors.white,
          foregroundColor: Colors.black
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(children: [
          const Text('1) Select a person photo (full-body or upper-body).', style: TextStyle(fontSize: 14)),
          const SizedBox(height: 8),
          imagePreview(person),
          const SizedBox(height: 8),
          Row(children: [
            ElevatedButton.icon(
              onPressed: pickPerson,
              icon: const Icon(Icons.person),
              label: const Text('Pick Person'),
            ),
            const SizedBox(width: 12),
            if (person != null) Text(person!.name, overflow: TextOverflow.ellipsis),
          ]),
          const Divider(height: 28),

          const Text('2) Select a garment image (isolated/transparent PNG preferred).', style: TextStyle(fontSize: 14)),
          const SizedBox(height: 8),
          imagePreview(garment),
          const SizedBox(height: 8),
          Row(children: [
            ElevatedButton.icon(
              onPressed: pickGarment,
              icon: const Icon(Icons.checkroom),
              label: const Text('Pick Garment'),
            ),
            const SizedBox(width: 12),
            if (garment != null) Text(garment!.name, overflow: TextOverflow.ellipsis),
          ]),
          const Divider(height: 28),

          const Text('3) Generate try-on', style: TextStyle(fontSize: 14)),
          const SizedBox(height: 8),
          Row(children: [
            ElevatedButton(
              onPressed: loading ? null : submitTryOn,
              child: loading ? const SizedBox(width: 20, height: 20, child: CircularProgressIndicator(strokeWidth: 2)) : const Text('Try On'),
            ),
            const SizedBox(width: 12),
            ElevatedButton(
              onPressed: (resultDataUrl == null) ? null : downloadResult,
              child: const Text('Download Result'),
            ),
            const SizedBox(width: 12),
            ElevatedButton(
              onPressed: (resultDataUrl == null) ? null : copyResultToClipboard,
              child: const Text('Copy Result URL'),
            ),
          ]),
          const SizedBox(height: 16),

          if (statusText.isNotEmpty)
            Align(
              alignment: Alignment.centerLeft,
              child: Text(statusText, style: const TextStyle(color: Colors.black54)),
            ),

          const SizedBox(height: 16),

          if (resultDataUrl != null) ...[
            const Divider(),
            const SizedBox(height: 8),
            const Text('Result', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
            const SizedBox(height: 8),
            Image.network(resultDataUrl!, fit: BoxFit.contain),
            const SizedBox(height: 12),
          ],
        ]),
      ),
    );
  }
}
